#version 460 core

#define cellIdsLength 0
#define cellsPerThread 10
#define threadsInBlock 1024


layout(local_size_x = 1024) in;
layout(std430) buffer;


layout(location = 0) uniform vec2 windowSize;
layout(location = 6) uniform float particleSize;
layout(location = 7) uniform uint cellSize;

struct Particle
{
	vec2 Pos;
	vec2 Vel;
	vec2 Acc;
	float Pressure;
	float Unused;
};

struct CollisionCellData
{
	uint index;
	uint neighbourAndHomeCellsCountPacked;
};

layout(binding = 0) buffer SSBO
{
	Particle particles[];
};
layout(binding = 6) buffer cells3
{
	uint cellIds[];
};
layout(binding = 8) buffer objects3
{
	uint objectIds[];
};
layout(binding = 9) buffer tetete
{
	float test[];
};

vec2 collisionResponse(float penetrationDepth, vec2 norm, vec2 relativeVel)
{
	const float k = 1.0;
	const float b = 0.05;

	float acc = k * penetrationDepth - b * dot(norm, relativeVel);

	return acc * norm;
}

vec2 calculateCollisionRepelForce(Particle p1, Particle p2, float distSquared, vec2 posDiff)
{
	const float dist = sqrt(distSquared);
	const vec2 norm = posDiff / dist;
	const float covered = particleSize - dist;

	return collisionResponse(covered, norm, p1.Vel - p2.Vel);
}

void main()
{
	const uint thid = gl_GlobalInvocationID.x;
	const uint startIndex = thid * cellsPerThread;

	const uint gridWidth = uint(windowSize.x / cellSize) + 2;

	CollisionCellData collisionCells[40];
	uint collisionCellsFound[4] = uint[4](0, 0, 0, 0);
	bool isFirstTransition = thid != 0;
	bool isTransitionFound = false;

	uint collisionCellIndex = startIndex;
	uint prevCellId = cellIds[startIndex];
	uint homeOrNeighbourCell = objectIds[startIndex] >> 31; // can be 1 (home) or 0 (neighbour)
	uint nCount = 1;
	nCount -= homeOrNeighbourCell;
	uint hCount = homeOrNeighbourCell;

	uint i;
	uint currCellId;
	for (i = 1; (i <= cellsPerThread + 1 || !isTransitionFound) && startIndex + i < cellIdsLength; i++)
	{
		isTransitionFound = false;
		currCellId = cellIds[startIndex + i];

		if (currCellId != prevCellId)
		{
			if (!isFirstTransition)
			{
				if (hCount > 0 && nCount > 0 || hCount > 1)
				{
					uint cellType = ((prevCellId % gridWidth) % 2) + ((prevCellId / gridWidth) % 2) * 2;
					collisionCells[cellType * 21 + collisionCellsFound[cellType]] = CollisionCellData(collisionCellIndex, hCount << 16 | nCount);
						collisionCellsFound[cellType]++;
				}
			}
			isFirstTransition = false;

			collisionCellIndex = startIndex + i;
			prevCellId = currCellId;
			nCount = 0;
			hCount = 0;

			isTransitionFound = true;
		}

		homeOrNeighbourCell = objectIds[startIndex + i] >> 31;
		nCount++;
		nCount -= homeOrNeighbourCell;
		hCount += homeOrNeighbourCell;
	}

	for (i = 0; i < 4; i++)
	{
		uint collCellFound = collisionCellsFound[i];

		for (uint j = 0; j < collCellFound; j++)
		{
			CollisionCellData collisionCell = collisionCells[i * 21 + j];
			collisionCellIndex = collisionCell.index;
			hCount = collisionCell.neighbourAndHomeCellsCountPacked >> 16;
			nCount = collisionCell.neighbourAndHomeCellsCountPacked & 65535;

			for (uint h = 0; h < hCount; h++)
			{
				Particle particleA = particles[objectIds[collisionCellIndex + h]];

				for (uint c = h + 1; c < hCount + nCount; c++)
				{
					Particle particleB = particles[objectIds[collisionCellIndex + c]];
					const vec2 posDiff = particleA.Pos - particleB.Pos;
					const float distSquared = dot(posDiff, posDiff);

					if (distSquared < particleSize * particleSize)
					{
						vec2 force = calculateCollisionRepelForce(particleA, particleB, distSquared, posDiff);

						particles[objectIds[collisionCellIndex + h]].Acc += force;
						particles[objectIds[collisionCellIndex + c]].Acc += -force;
					}
				}
			}
		}

		barrier();
	}
}
