#version 460 core

#define cellIdsLength 0
#define cellsPerThread 10
#define threadsInBlock 1024


layout(local_size_x = 1024) in;
layout(std430) buffer;


layout(location = 0) uniform vec2 windowSize;
layout(location = 6) uniform float particleSize;
layout(location = 7) uniform uint cellSize;

struct Particle
{
	vec2 Pos;
	vec2 Vel;
	vec2 Acc;
	float Pressure;
	float Unused;
};

struct collCell
{
	uint index;
	uint phantomAndHomeCellsCountPacked;
};

layout(binding = 0) buffer SSBO
{
	Particle particles[];
};
layout(binding = 6) buffer cells3
{
	uint cellIds[];
};
layout(binding = 8) buffer objects3
{
	uint objectIds[];
};
layout(binding = 9) buffer tetete
{
	float test[];
};


void main()
{
	const uint thid = gl_GlobalInvocationID.x;
//	const uint thid = gl_LocalInvocationID.x;
	const uint startIndex = thid * cellsPerThread;
	if (startIndex >= cellIdsLength)
		return;
uint t = 0;
for(int o = 0;o<100;o++){test[o]=0;}
	const uint gridWidth = uint(windowSize.x / cellSize) + 2;

	collCell collisionCells[84];
	uint collisionCellsFound[4] = uint[4](0);
	bool isFirstTransition = thid != 0;
	bool isTransitionFound = false;

	uint collisionCellIndex = startIndex;
	uint prevCellId = cellIds[startIndex];
	uint homeOrPhantomCell = objectIds[startIndex] >> 31;
	uint pCount = 1;
	pCount -= homeOrPhantomCell;
	uint hCount = homeOrPhantomCell;

	uint i;
	uint currCellId;
	for (i = 1; (i <= cellsPerThread || !isTransitionFound) && startIndex + i < cellIdsLength; i++)
	{
		isTransitionFound = false;
		currCellId = cellIds[startIndex + i];

		if (currCellId != prevCellId)
		{
			if (!isFirstTransition)
			{
				if (hCount > 0 && pCount > 0 || hCount > 1)
				{
					uint cellType = ((prevCellId % gridWidth) % 2) + ((prevCellId / gridWidth) % 2) * 2;
					collisionCells[cellType * 21 + collisionCellsFound[cellType]] = collCell(collisionCellIndex, hCount << 16 | pCount);
						collisionCellsFound[cellType]++;
				}
			}
			isFirstTransition = false;

			collisionCellIndex = startIndex + i;
			prevCellId = currCellId;
			pCount = 0;
			hCount = 0;

			isTransitionFound = true;
		}

		homeOrPhantomCell = objectIds[startIndex + i] >> 31;
		pCount++;
		pCount -= homeOrPhantomCell;
		hCount += homeOrPhantomCell;
	}

//	currCellId = cellIds[startIndex + i];
//	if (currCellId != prevCellId)
//	{
//		collisionCellIndex = startIndex + i;
//		prevCellId = currCellId;
//		pCount = 0;
//		hCount = 0;
//	}
//
//	while (cellIds[startIndex + i] == prevCellId && startIndex + i < cellIdsLength)
//	{
//		homeOrPhantomCell = objectIds[startIndex + i] >> 31;
//		pCount++;
//		pCount -= homeOrPhantomCell;
//		hCount += homeOrPhantomCell;
//		i++;
//	}
//
//	if (hCount > 0 && pCount > 0)
//	{
//		uint cellType = ((prevCellId % gridWidth) % 2) + ((prevCellId / gridWidth) % 2) * 2;
//		collisionCells[cellType * 21 + collisionCellsFound[cellType]] = collCell(collisionCellIndex, hCount << 16 | pCount);
//		collisionCellsFound[cellType]++;
//	}

test[thid * 2]=startIndex;
test[thid * 2 + 1]=startIndex + i;
//if (thid == 1700){
//test[t++]=startIndex;
//}
//if (thid == 0)
//{
//for (i = 0; i < 84; i++)
//{
//test[i] = collisionCells[i] >> 16 & 255;
//}
//}
//return;
	for (i = 0; i < 4; i++)
	{
		uint collCellFound = collisionCellsFound[i];

		for (uint j = 0; j < collCellFound; j++)
		{
			collCell collisionCell = collisionCells[i * 21 + j];
			collisionCellIndex = collisionCell.index;
			hCount = collisionCell.phantomAndHomeCellsCountPacked >> 16;
			pCount = collisionCell.phantomAndHomeCellsCountPacked & 65535;
//if (thid == 1){
//test[t++]=collisionCellIndex;
//}
			for (uint h = 0; h < hCount; h++)
			{
				Particle particleA = particles[objectIds[collisionCellIndex + h]];
//if (collisionCellIndex == 32){
//test[t++]=hCount + pCount;
//}
				for (uint c = h + 1; c < hCount + pCount; c++)
				{
					Particle particleB = particles[objectIds[collisionCellIndex + c]];
					const vec2 posDiff = particleA.Pos - particleB.Pos;
					const float distSquared = dot(posDiff, posDiff);

					if (distSquared < particleSize * particleSize)
					{
						const float dist = sqrt(distSquared);
						const vec2 norm = posDiff / dist;
						const float covered = particleSize - dist;
//if (thid == 0){
//test[0] = t++;
//test[t++] = objectIds[collisionCellIndex + h] & 65535;
//test[t++] = objectIds[collisionCellIndex + c] & 65535;
//test[t++] = collisionCellIndex;
//test[t++] = pCount;
//test[t++] = hCount;
//}
						particles[objectIds[collisionCellIndex + h]].Vel += norm * 0.1;
						particles[objectIds[collisionCellIndex + c]].Vel += -norm * 0.1;
					}
				}
			}
		}

		barrier();
	}
}
