#version 460 core

#define radixCountersLength 1
#define threadsInThreadGroup 0
#define threadGroupsInWorkGroup 0
#define elementsPerGroup 0
#define threadGroupsTotal 1
#define sharedCountersSize 1024
#define iterations 0

layout(local_size_x = sharedCountersSize) in;
layout(std430) buffer;


layout(binding = 3) buffer counters
{
	uint globalCounters[];
};
layout(binding = 4) buffer totalSumm
{
	uint totalSumms[radixCountersLength];
};
layout(binding = 9) buffer tetete
{
	float test[];
};

shared uint iterationTotal = 0;
shared uint sharedCounters[sharedCountersSize];


void presumm(uint thid, uint n)
{
	uint offset = 1;

	for (uint d = n>>1; d > 0; d >>= 1)
	{ 
		barrier();
		if (thid < d)
		{
			// B
			uint ai = offset*(2*thid+1)-1;
			uint bi = offset*(2*thid+2)-1;
			// B
			sharedCounters[bi] += sharedCounters[ai];
		}
		offset *= 2;
	}

	// C
	if (thid == 0) // clear the last element
	{
		sharedCounters[n - 1] = 0;
	}
	// C

	for (uint d = 1; d < n; d *= 2) // traverse down tree & build scan
	{
		offset >>= 1;
		barrier();

		if (thid < d)
		{
			// D
			uint ai = offset*(2*thid+1)-1;
			uint bi = offset*(2*thid+2)-1; 
			// D
			uint t = sharedCounters[ai];
			sharedCounters[ai] = sharedCounters[bi];
			sharedCounters[bi] += t;
		}
	}
}

void main()
{
	const uint thid = gl_LocalInvocationID.x;

	const uint totalGlobalCounters = threadGroupsTotal * radixCountersLength;

	for (uint i = 0; i < iterations; i++)
	{
		// TODO maybe change global counters layout to get better memroy read coalescing
		uint globalCounterIndex = thid * radixCountersLength + sharedCountersSize * radixCountersLength * i + gl_WorkGroupID.x;
		uint currentCounter = globalCounters[globalCounterIndex];

		uint m = globalCounterIndex < totalGlobalCounters ? 1 : 0;
		sharedCounters[thid] = currentCounter * m;

		presumm(thid, sharedCountersSize);
		barrier();
		if (globalCounterIndex < totalGlobalCounters)
		{
			globalCounters[globalCounterIndex] = sharedCounters[thid] + iterationTotal;
		}

		if (thid == sharedCountersSize - 1 && i == iterations - 1) // last thread of last iteration writes total summ to global
		{
			totalSumms[gl_WorkGroupID.x] = sharedCounters[sharedCountersSize - 1] + iterationTotal + currentCounter;
//if(i == iterations - 1 && gl_WorkGroupID.x == 70){test[0] = currentCounter;}
		}

		barrier();
		if (thid == sharedCountersSize - 1) // last thread of current iteration writes total summ for next iteration to use
		{
			iterationTotal = globalCounters[globalCounterIndex] + currentCounter;
		}
	}
}
