#version 460 core

#define cellIdsLength 0
#define cellsPerThread 1

#define threadsInWorkGroup 1024

layout(local_size_x = threadsInWorkGroup) in;
layout(std430) buffer;


layout(location = 0) uniform vec2 windowSize;
layout(location = 1) uniform float particleSize;
layout(location = 2) uniform uint cellSize;
layout(location = 3) uniform float forceScale;

struct Particle
{
	vec2 Pos;
	vec2 PosPrev;
	vec2 Acc;
	float Pressure;
	float Unused;
};
struct collCell
{
	uint index;
	uint phantomAndHomeCellsCountPacked;
};

layout(binding = 0) buffer SSBO
{
	Particle particles[];
};
layout(binding = 1) buffer cells1
{
	uint cellIds[];
};
layout(binding = 2) buffer objects1
{
	uint objectIds[];
};
layout(binding = 9) buffer tetete
{
	float test[];
};
layout(binding = 10) buffer collisionList
{
	uint collisionCells[];
};
layout(binding = 11) buffer cellIdsLookup
{
	uint cellIdToCollisionListIdLookup[];
};
layout(binding = 12) buffer collCellsFound
{
	uint collCellsFoundPerWorkGroup[];
};


shared uint sharedCollCellsFound[threadsInWorkGroup];


void presumm(uint thid)
{
	uint n = threadsInWorkGroup;
	uint offset = 1;

	for (uint d = n>>1; d > 0; d >>= 1)
	{ 
		barrier();
		if (thid < d)
		{
			// B
			uint ai = offset*(2*thid+1)-1;
			uint bi = offset*(2*thid+2)-1;
			// B
			sharedCollCellsFound[bi] += sharedCollCellsFound[ai];
		}
		offset *= 2;
	}

	// C
	if (thid == 0) // clear the last element
	{
		sharedCollCellsFound[n - 1] = 0;
	}
	// C

	for (uint d = 1; d < n; d *= 2) // traverse down tree & build scan
	{
		offset >>= 1;
		barrier();

		if (thid < d)
		{
			// D
			uint ai = offset*(2*thid+1)-1;
			uint bi = offset*(2*thid+2)-1; 
			// D
			uint t = sharedCollCellsFound[ai];
			sharedCollCellsFound[ai] = sharedCollCellsFound[bi];
			sharedCollCellsFound[bi] += t;
		}
	}
}

void main()
{
	const uint thid = gl_LocalInvocationID.x;
//test[thid]=cellIdToCollisionListIdLookup[thid];
	const uint totalOffset = gl_WorkGroupID.x * threadsInWorkGroup * cellsPerThread + thid * cellsPerThread; // work group offset plus cells per thread offest

	sharedCollCellsFound[thid] = 0;

	uint cellIdsMetByThread[cellsPerThread] = uint[cellsPerThread](0);
	uint transitionIndexes[cellsPerThread] = uint[cellsPerThread](0);
	uint collisionCellsFound = 0;

	uint prevCellId = cellIds[totalOffset];

	// first thread of first work group ahould always find one collision cell
	// so for that thread isCollisionCellSplit should always be false in the beginning
	uint prevThreadCellId = int(totalOffset) - 1 < 0
		? -1 // because of uint -1 gets converted to max value, prevCellId will never be equal max value
		: cellIds[totalOffset - 1];
	bool isCollisionCellSplit = prevThreadCellId == prevCellId; // previous thread ended and current thread started in the middle of collisoin cell

	if (!isCollisionCellSplit && totalOffset < cellIdsLength)
	{
		transitionIndexes[0] = totalOffset;
		cellIdsMetByThread[0] = prevCellId;
		collisionCellsFound++;
	}

	for (uint i = 1; i < cellsPerThread && totalOffset + i < cellIdsLength; i++)
	{
		uint currCellId = cellIds[totalOffset + i];

//		bool isCellDifferent = prevCellId == currCellId;
		if (prevCellId != currCellId)
		{
			transitionIndexes[collisionCellsFound] = totalOffset + i;
			cellIdsMetByThread[collisionCellsFound] = currCellId;
			collisionCellsFound++;
		}

//		collisionCellsFound += int(isCellDifferent);

		prevCellId = currCellId;
	}

//	collisionCellsFound += uint(cellIdsLength - totalOffset) <= cellsPerThread ? 1 : 0; // fix for last thread of last workgroup missing last collision cell

//	uint change = cellsPerThreadOffest < cellIdsLength ? uint(isCollisionCellSplit) : 0;
//	collisionCellsFound -= uint(isCollisionCellSplit);
	sharedCollCellsFound[thid] = collisionCellsFound;
//barrier();
//test[thid]=sharedCollCellsFound[thid];
//barrier();

	presumm(thid);
	barrier();

//if(gl_WorkGroupID.x==0)test[thid]=collisionCellsFound;

	for (uint i = 0; i < collisionCellsFound && totalOffset + i < cellIdsLength; i++)
	{
//test[thid]=thid;
		const uint collCellId = sharedCollCellsFound[thid] + i + gl_WorkGroupID.x * threadsInWorkGroup * cellsPerThread;
//if(thid==288)test[i]=transitionIndexes[i];
		collisionCells[collCellId] = transitionIndexes[i];

//		const uint cellId = cellIdsMetByThread[i];
//		cellIdToCollisionListIdLookup[cellId] = collCellId + 1; // 0 value means no collision cell there
//test[cellId]=collCellId + 1;
	}

	if (thid == threadsInWorkGroup - 1)
	{
		collCellsFoundPerWorkGroup[gl_WorkGroupID.x] = sharedCollCellsFound[threadsInWorkGroup - 1] + collisionCellsFound;
	}
}






void oldmain()
{
	const uint thid = gl_GlobalInvocationID.x;
	const uint startIndex = thid * cellsPerThread;

	const uint gridWidth = uint(windowSize.x / cellSize);

	collCell collCells[84];
	uint collisionCellsFound[4] = uint[4](0, 0, 0, 0);
	bool isFirstTransition = thid != 0;
	bool isTransitionFound = false;

	uint collisionCellIndex = startIndex;
	uint prevCellId = cellIds[startIndex];
	uint homeOrPhantomCell = objectIds[startIndex] >> 31;
	uint pCount = 1;
	pCount -= homeOrPhantomCell;
	uint hCount = homeOrPhantomCell;

	uint i;
	uint currCellId;
	for (i = 1;
		(i <= cellsPerThread + 1 || !isTransitionFound) // scanning until the transition is found after the end of assigned to thread part of cellIds
		&& startIndex + i < cellIdsLength + 1; // scanning past the end of cellIds to catch a collision cell at the end of cellIds
		i++)
	{
		isTransitionFound = false;
		currCellId = cellIds[startIndex + i];

		if (currCellId != prevCellId)
		{
			if (!isFirstTransition) // thread number 0 is the only one which will enter here on the first iteration, next iterations all threads are entering
			{
				if (hCount > 0 && pCount > 0 || hCount > 1)
				{
					uint cellType = ((prevCellId % gridWidth) % 2) + ((prevCellId / gridWidth) % 2) * 2;
					collCells[cellType * 21 + collisionCellsFound[cellType]] = collCell(collisionCellIndex, hCount << 16 | pCount);
					collisionCellsFound[cellType]++;
				}
			}
			isFirstTransition = false;

			collisionCellIndex = startIndex + i;
			prevCellId = currCellId;
			pCount = 0;
			hCount = 0;

			isTransitionFound = true;
		}

		homeOrPhantomCell = objectIds[startIndex + i] >> 31; // 1 - home, 0 - phantom
		pCount += 1 - homeOrPhantomCell;
		hCount += homeOrPhantomCell;
	}

	for (i = 0; i < 4; i++)
	{
		uint collCellFound = collisionCellsFound[i];

		for (uint j = 0; j < collCellFound; j++)
		{
			collCell collisionCell = collCells[i * 21 + j];
			collisionCellIndex = collisionCell.index;
			hCount = collisionCell.phantomAndHomeCellsCountPacked >> 16;
			pCount = collisionCell.phantomAndHomeCellsCountPacked & 65535;
			for (uint h = 0; h < hCount; h++)
			{
				Particle particleA = particles[objectIds[collisionCellIndex + h]];
				for (uint c = h + 1; c < hCount + pCount; c++)
				{
					Particle particleB = particles[objectIds[collisionCellIndex + c]];
					const vec2 posDiff = particleA.Pos - particleB.Pos + 0.0000000000001; // for case when two particles have exaclty the same posision
					const float distSquared = dot(posDiff, posDiff);

					if (distSquared < particleSize * particleSize)
					{
						const float dist = sqrt(distSquared);
						const vec2 norm = posDiff / dist;
						const float covered = particleSize - dist;

//						particleA.PosPrev = particleA.Pos;
//						particleB.PosPrev = particleB.Pos;

						vec2 move = norm * covered * 0.5 * forceScale;
						particleA.Pos += move;
						particleB.Pos -= move;

						particleA.Pressure += covered / particleSize * 0.5; // TODO divide by substeps
						particleB.Pressure += covered / particleSize * 0.5;

						particles[objectIds[collisionCellIndex + h]] = particleA;
						particles[objectIds[collisionCellIndex + c]] = particleB;
					}
				}
			}
		}

		barrier();
	}
}
