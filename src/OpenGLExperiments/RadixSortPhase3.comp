#version 460 core

#define cellIdsLength 0
#define threadsInWorkGroup 1
#define threadsInThreadGroup 0
#define threadGroupsInWorkGroup 1
#define elementsPerGroup 0
#define sharedCountersLength 12032

#define cellIdShift 0

#define bindingCellIdsInput 1
#define bindingCellIdsOutput 5
#define bufferCellIdsInput cells1
#define bufferCellIdsOutput cells2

#define bindingObjectIdsInput 2
#define bindingObjectIdsOutput 7
#define bufferObjectIdsInput objects1
#define bufferObjectIdsOutput objects2

layout(local_size_x = threadsInWorkGroup) in;
layout(std430) buffer;


layout(binding = bindingCellIdsInput) buffer bufferCellIdsInput
{
	uint cellIdsInput[];
};
layout(binding = bindingObjectIdsInput) buffer bufferObjectIdsInput
{
	uint objectIdsInput[];
};
layout(binding = 3) buffer counters
{
	uint globalCounters[];
};
layout(binding = 4) buffer totalSumm
{
	uint totalSumms[256];
};
layout(binding = bindingCellIdsOutput) buffer bufferCellIdsOutput
{
	uint cellIdsOutput[];
};
layout(binding = bindingObjectIdsOutput) buffer bufferObjectIdsOutput
{
	uint objectIdsOutput[];
};
layout(binding = 9) buffer tetete
{
	float test[];
};

shared uint totalSummShared[256];
shared uint sharedCounters[sharedCountersLength];


void presumm(uint thid, uint n)
{
	uint offset = 1;

	for (uint d = n>>1; d > 0; d >>= 1)
	{ 
		barrier();
		if (thid < d)
		{
			// B
			uint ai = offset*(2*thid+1)-1;
			uint bi = offset*(2*thid+2)-1;
			// B
			totalSummShared[bi] += totalSummShared[ai];
		}
		offset *= 2;
	}

	// C
	if (thid == 0) // clear the last element
	{
		totalSummShared[n - 1] = 0;
	}
	// C

	for (uint d = 1; d < n; d *= 2) // traverse down tree & build scan
	{
		offset >>= 1;
		barrier();

		if (thid < d)
		{
			// D
			uint ai = offset*(2*thid+1)-1;
			uint bi = offset*(2*thid+2)-1; 
			// D
			uint t = totalSummShared[ai];
			totalSummShared[ai] = totalSummShared[bi];
			totalSummShared[bi] += t;
		}
	}
}

void main()
{
int t=0;
if (cellIdShift != 0){for (int ii = 0; ii < 400; ii++) test[ii] = 777;}
	const uint thid = gl_LocalInvocationID.x;
	const uint indexInWrap = uint(mod(thid, 16));
	uint i;

	for (i = 0; thid + i < 256; i += threadsInWorkGroup)
	{
		totalSummShared[thid + i] = totalSumms[thid + i];
	}

//for (i = 0; thid + i < 256; i += threadsInWorkGroup)
//{
//	test[thid + i] = totalSumms[thid + i];
//}

	presumm(thid, 256);

	barrier();

	for (i = 0; thid + i < sharedCountersLength; i += threadsInWorkGroup)
	{
		sharedCounters[thid + i] = globalCounters[thid + i + sharedCountersLength * gl_WorkGroupID.x] + totalSummShared[uint(mod(thid + i, 256))];
	}

for (i = 0; thid + i < sharedCountersLength; i += threadsInWorkGroup)
{
	test[thid + i + 50] = sharedCounters[thid + i];
}
//for (i = 0; thid + i < sharedCountersLength; i += threadsInWorkGroup)
//{
//	test[thid + i] = globalCounters[thid + i + sharedCountersLength * gl_WorkGroupID.x];
//}
//for (i = 0; thid + i < 256; i += threadsInWorkGroup)
//{
//	test[thid + i] = totalSummShared[thid + i];
//}

	barrier();

	const uint indexInGroup = uint(mod(gl_LocalInvocationID.x, threadsInThreadGroup));
	const uint groupIndex = gl_LocalInvocationID.x / threadsInThreadGroup;
	const uint cellIndex = (gl_WorkGroupID.x * (threadGroupsInWorkGroup - 1) + groupIndex) * elementsPerGroup + indexInGroup;
	const uint counterIndexOffset = groupIndex * 256;
		
	uint offset;
	for (i = 0; i < elementsPerGroup; i += threadsInThreadGroup)
	{
		const uint cellId = cellIdsInput[cellIndex + i];
		const uint objectId = objectIdsInput[cellIndex + i];
		const uint radix = (cellId >> cellIdShift) & 255;
		const uint indexInSharedCounters = counterIndexOffset + radix;

		barrier();

		if (cellIndex + i < cellIdsLength && thid < threadsInWorkGroup - threadsInThreadGroup)
		{
			for (uint j = 0; j < 16; j++)
			{
//if (cellIdShift == 0) {
//test[t++] = 999.0;
//}
				if (indexInWrap == j)
				{
					offset = sharedCounters[indexInSharedCounters];

					cellIdsOutput[offset] = cellId;
					objectIdsOutput[offset] = objectId;
if (cellIdShift != 0){
test[gl_GlobalInvocationID.x]=groupIndex;
test[gl_GlobalInvocationID.x + 10]=counterIndexOffset;
test[gl_GlobalInvocationID.x + 20]=radix;
test[gl_GlobalInvocationID.x + 30]=indexInSharedCounters;
test[gl_GlobalInvocationID.x + 40]=offset;
}
					sharedCounters[indexInSharedCounters]++;

//if (cellIdShift != 0) {
//if (objectId == 0){
//test[gl_WorkGroupID.x * 5 + t++] = float(cellIndex + i);
//}}
				}
			}
		}
	}

//	for (i = 0; thid + i < sharedCountersLength; i += threadsInWorkGroup)
//	{
//		globalCounters[thid + i + sharedCountersLength * gl_WorkGroupID.x] = sharedCounters[thid + i];
//	}

//	for (uint i = 0; thid + i < 256; i += threadsInWorkGroup)
//	{
//		totalSumms[thid + i] = totalSummShared[thid + i];
//	}
}
