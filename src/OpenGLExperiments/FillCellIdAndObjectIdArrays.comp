#version 460 core

// 0 is replaced at runtime with an actual value
#define particlesCount 0

layout(local_size_x = 64) in;
layout(std430) buffer;

layout(location = 0) uniform vec2 windowSize;
layout(location = 1) uniform float forceScale;
layout(location = 2) uniform float velocityDamping;
layout(location = 3) uniform float minDistanceToAttractor;
layout(location = 4) uniform float deltaTime;
layout(location = 5) uniform bool isPaused;
layout(location = 6) uniform float particleSize;
layout(location = 7) uniform uint cellSize;

layout(binding = 0) buffer SSBO
{
	vec4 particleData[];
};
layout(binding = 1) buffer cells
{
	uint cellIds[];
};
layout(binding = 2) buffer objects
{
	vec4 objectIds[];
};


uint findHomeCell(uint particleIndex)
{
	uint gridWidth = uint(windowSize.x / cellSize) + 1;
	vec2 windowPos = particleData[particleIndex].xy;
	vec2 gridPos = windowPos / cellSize;

	return uint(gridPos.x) + uint(gridPos.y) * gridWidth;
}

uvec3 findPhantomCells(uint particleIndex)
{
	uint gridWidth = uint(windowSize.x / cellSize) + 1;
	vec2 windowPos = particleData[particleIndex].xy;
	vec2 gridPos = windowPos / cellSize;

	return uvec3(0.0);
}


void main()
{
	uint tId = gl_GlobalInvocationID.x;
	if (tId > particlesCount) return;

	uint hCellId = findHomeCell(tId);
	uvec3 pCellIds = findPhantomCells(tId);

	uint cellIndex = tId * 2;
	cellIds[cellIndex] = pCellIds.x << 16 | hCellId;
	cellIds[cellIndex + 1] = pCellIds.z << 16 | pCellIds.y;

//	cellIds[0] = 32 << 16 | 84; // 84 becomes zero index
}
