#version 460 core

// 0 is replaced at runtime with an actual value
#define particlesCount 0

layout(local_size_x = 64) in;
layout(std430) buffer;

layout(location = 0) uniform vec2 windowSize;
layout(location = 1) uniform float forceScale;
layout(location = 2) uniform float velocityDamping;
layout(location = 3) uniform float minDistanceToAttractor;
layout(location = 4) uniform float deltaTime;
layout(location = 5) uniform bool isPaused;
layout(location = 6) uniform float particleSize;
layout(location = 7) uniform uint cellSize;

struct Particle
{
	vec2 Pos;
	vec2 Vel;
	vec2 Acc;
	float Pressure;
	float Unused;
};

layout(binding = 0) buffer SSBO
{
	Particle particles[];
};
layout(binding = 1) buffer cells1
{
	uint cellIds1[];
};
layout(binding = 2) buffer objects1
{
	uint objectIds[];
};

void main()
{
	uint thid = gl_GlobalInvocationID.x;
	if (thid >= particlesCount)
		return;

	uint gridWidth = uint(windowSize.x / cellSize) + 2; // make grid bigger than screen because particle can intersect screen edges
	vec2 gridPos; // integer part of mod operation
	vec2 cellPos = modf(particles[thid].Pos / cellSize, gridPos); // float part of mod operation
	gridPos += 1; // because grid is bigger than screen particle grid position calculation is of by 1

	uint hCellId = uint(gridPos.x + gridPos.y * gridWidth); // home cell i.e cell where particle's center lands
	uvec3 pCellIds = uvec3(-1); // if particle does not intersect a phantom cell, the cell stays marked as not valid by value -1

	// TODO differently sized particles
	// TODO fix diagonal P cells
	if (cellPos.x > 0.5)
	{
		pCellIds.x = hCellId + 1; // right neighbour
		if (cellPos.y > 0.5)
		{
			pCellIds.y = hCellId + gridWidth;
			pCellIds.z = hCellId + gridWidth + 1; // diagonal
		}
		else
		{
			pCellIds.y = hCellId - gridWidth;
			pCellIds.z = hCellId - gridWidth + 1; // diagonal
		}
	}
	else
	{
		pCellIds.x = hCellId - 1; // left neighbour
		if (cellPos.y > 0.5)
		{
			pCellIds.y = hCellId + gridWidth;
			pCellIds.z = hCellId + gridWidth - 1; // diagonal
		}
		else
		{
			pCellIds.y = hCellId - gridWidth;
			pCellIds.z = hCellId - gridWidth - 1; // diagonal
		}
	}

	cellIds1[thid] = hCellId;
	cellIds1[thid + particlesCount] = pCellIds.x;
	cellIds1[thid + particlesCount * 2] = pCellIds.y;
	cellIds1[thid + particlesCount * 3] = pCellIds.z;

	objectIds[thid] = thid | 0x80000000; // most significant bit is indicating a home cell. 0 becomes 2147483648
	objectIds[thid + particlesCount] = thid;
	objectIds[thid + particlesCount * 2] = thid;
	objectIds[thid + particlesCount * 3] = thid;
}
